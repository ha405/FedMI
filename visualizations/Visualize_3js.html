<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FL Circuit Visualizer</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600;700&family=Space+Grotesk:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        :root {
            --bg-primary: #0a0a0f;
            --bg-secondary: #12121a;
            --bg-tertiary: #1a1a25;
            --accent-cyan: #00f5d4;
            --accent-magenta: #f72585;
            --accent-blue: #4361ee;
            --accent-purple: #7209b7;
            --text-primary: #f0f0f5;
            --text-secondary: #8888a0;
            --border-color: rgba(255,255,255,0.08);
        }
        
        body {
            font-family: 'Space Grotesk', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
        }
        
        #app {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        /* Header Controls */
        #header {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            padding: 12px 20px;
            display: flex;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
            z-index: 100;
        }
        
        .logo {
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            font-weight: 700;
            color: var(--accent-cyan);
            text-transform: uppercase;
            letter-spacing: 2px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .logo::before {
            content: '';
            width: 8px;
            height: 8px;
            background: var(--accent-cyan);
            border-radius: 50%;
            box-shadow: 0 0 10px var(--accent-cyan);
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .control-group label {
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: var(--text-secondary);
            font-family: 'JetBrains Mono', monospace;
        }
        
        select, button {
            font-family: 'Space Grotesk', sans-serif;
            padding: 8px 14px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 120px;
        }
        
        select:hover, button:hover {
            border-color: var(--accent-cyan);
            background: rgba(0, 245, 212, 0.05);
        }
        
        select:focus, button:focus {
            outline: none;
            border-color: var(--accent-cyan);
            box-shadow: 0 0 0 3px rgba(0, 245, 212, 0.1);
        }
        
        select option {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }
        
        button.active {
            background: var(--accent-cyan);
            color: var(--bg-primary);
            border-color: var(--accent-cyan);
            font-weight: 600;
        }
        
        .file-btn {
            background: linear-gradient(135deg, var(--accent-blue), var(--accent-purple));
            border: none;
            font-weight: 600;
            padding: 10px 18px;
        }
        
        .file-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 20px rgba(67, 97, 238, 0.4);
        }
        
        #fileInput { display: none; }
        
        .divider {
            width: 1px;
            height: 40px;
            background: var(--border-color);
        }
        
        .panel-group {
            display: flex;
            gap: 12px;
            padding: 10px 14px;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }
        
        .panel-title {
            font-size: 11px;
            font-weight: 700;
            color: var(--accent-cyan);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
            font-family: 'JetBrains Mono', monospace;
        }
        
        .panel-title.right { color: var(--accent-magenta); }
        
        /* Stats Panel */
        #stats {
            margin-left: auto;
            display: flex;
            gap: 20px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
        }
        
        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 2px;
        }
        
        .stat-label {
            color: var(--text-secondary);
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .stat-value {
            font-weight: 700;
            font-size: 16px;
        }
        
        .stat-value.left { color: var(--accent-cyan); }
        .stat-value.right { color: var(--accent-magenta); }
        
        /* Canvas Area */
        #canvas-area {
            flex: 1;
            display: flex;
            position: relative;
            overflow: hidden;
        }
        
        .view-panel {
            flex: 1;
            position: relative;
            min-width: 0;
        }
        
        .view-panel.hidden { display: none; }
        
        .view-panel canvas {
            display: block;
            width: 100% !important;
            height: 100% !important;
        }
        
        .view-label {
            position: absolute;
            top: 16px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            backdrop-filter: blur(10px);
            padding: 10px 20px;
            border-radius: 25px;
            font-size: 12px;
            font-weight: 600;
            z-index: 10;
            border: 1px solid var(--border-color);
            font-family: 'JetBrains Mono', monospace;
            letter-spacing: 0.5px;
        }
        
        .view-label.left { border-color: var(--accent-cyan); }
        .view-label.right { border-color: var(--accent-magenta); }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: var(--text-secondary);
            font-family: 'JetBrains Mono', monospace;
        }
        
        #loading .icon {
            font-size: 48px;
            margin-bottom: 16px;
            opacity: 0.5;
        }
        
        #loading .text {
            font-size: 14px;
            letter-spacing: 1px;
        }
        
        /* Legend */
        #legend {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.85);
            backdrop-filter: blur(10px);
            padding: 16px 20px;
            border-radius: 12px;
            border: 1px solid var(--border-color);
            font-size: 12px;
            z-index: 10;
            display: none;
        }
        
        .legend-title {
            font-weight: 700;
            margin-bottom: 12px;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-size: 10px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
            color: var(--text-secondary);
        }
        
        .legend-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }
        
        .legend-line {
            width: 24px;
            height: 3px;
            border-radius: 2px;
        }
        
        /* Responsive */
        @media (max-width: 1200px) {
            #header { padding: 10px 12px; gap: 12px; }
            .panel-group { flex-direction: column; gap: 8px; }
        }
    </style>
</head>
<body>
    <div id="app">
        <div id="header">
            <div class="logo">FL Circuits</div>
            
            <label for="fileInput" class="file-btn" style="cursor: pointer;">
                ğŸ“‚ Load JSON
            </label>
            <input type="file" id="fileInput" accept=".json">
            
            <div class="divider"></div>
            
            <div class="control-group">
                <label>Round</label>
                <select id="roundSelect"><option value="">â€” Select â€”</option></select>
            </div>
            
            <button id="toggleCompare">â—§ Compare</button>
            <button id="toggleOverlay" style="display:none;">â—‰ Overlay Diff</button>
            
            <div class="divider"></div>
            
            <!-- Left Panel Controls -->
            <div class="panel-group" id="leftControls">
                <div style="margin-bottom: 4px;" class="panel-title">Left View</div>
                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                    <div class="control-group">
                        <label>Model</label>
                        <select id="modelType1">
                            <option value="clients_local_model">Local</option>
                            <option value="clients_global_model">Global</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Client</label>
                        <select id="clientSelect1"><option value="">â€”</option></select>
                    </div>
                    <div class="control-group">
                        <label>Class</label>
                        <select id="classSelect1"><option value="">â€”</option></select>
                    </div>
                </div>
            </div>
            
            <!-- Right Panel Controls (hidden by default) -->
            <div class="panel-group" id="rightControls" style="display: none;">
                <div style="margin-bottom: 4px;" class="panel-title right">Right View</div>
                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                    <div class="control-group">
                        <label>Model</label>
                        <select id="modelType2">
                            <option value="clients_local_model">Local</option>
                            <option value="clients_global_model">Global</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Client</label>
                        <select id="clientSelect2"><option value="">â€”</option></select>
                    </div>
                    <div class="control-group">
                        <label>Class</label>
                        <select id="classSelect2"><option value="">â€”</option></select>
                    </div>
                </div>
            </div>
            
            <!-- Stats -->
            <div id="stats">
                <div class="stat-item">
                    <span class="stat-label">Neurons (L)</span>
                    <span class="stat-value left" id="neurons1">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Connections (L)</span>
                    <span class="stat-value left" id="conns1">0</span>
                </div>
                <div class="stat-item" id="statNeurons2" style="display:none;">
                    <span class="stat-label">Neurons (R)</span>
                    <span class="stat-value right" id="neurons2">0</span>
                </div>
                <div class="stat-item" id="statConns2" style="display:none;">
                    <span class="stat-label">Connections (R)</span>
                    <span class="stat-value right" id="conns2">0</span>
                </div>
            </div>
        </div>
        
        <div id="canvas-area">
            <div class="view-panel" id="view1">
                <div class="view-label left" id="label1"></div>
                <div id="loading">
                    <div class="icon">â¬¡</div>
                    <div class="text">Load a circuits JSON file to begin</div>
                </div>
            </div>
            <div class="view-panel hidden" id="view2">
                <div class="view-label right" id="label2"></div>
            </div>
        </div>
        
        <div id="legend">
            <div class="legend-title">Legend (Overlay Mode)</div>
            <div class="legend-item">
                <div class="legend-dot" style="background: #00f5d4;"></div>
                <span>Active neuron (Left)</span>
            </div>
            <div class="legend-item">
                <div class="legend-dot" style="background: #f72585;"></div>
                <span>Active neuron (Right only)</span>
            </div>
            <div class="legend-item">
                <div class="legend-line" style="background: #f72585;"></div>
                <span>Connection only in Left</span>
            </div>
            <div class="legend-item">
                <div class="legend-line" style="background: #00f5d4;"></div>
                <span>Connection only in Right</span>
            </div>
            <div class="legend-item">
                <div class="legend-line" style="background: #666;"></div>
                <span>Shared connection</span>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // STATE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        let jsonData = null;
        let compareMode = false;
        let overlayMode = false;
        
        // View state for left and right
        const views = {
            left: { scene: null, camera: null, renderer: null, objects: [], data: null },
            right: { scene: null, camera: null, renderer: null, objects: [], data: null }
        };
        
        // Layer configuration (will be detected from data)
        const LAYER_SIZES = { conv1: 32, conv2: 64, conv3: 128, fc: 10 };
        const LAYER_ORDER = ['conv1', 'conv2', 'conv3', 'fc'];
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // THREE.JS INITIALIZATION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function initView(viewKey, container) {
            const view = views[viewKey];
            
            view.scene = new THREE.Scene();
            view.scene.background = new THREE.Color(0x000000);
            
            view.camera = new THREE.PerspectiveCamera(
                60, 
                container.clientWidth / container.clientHeight, 
                0.1, 
                1000
            );
            view.camera.position.set(0, 0, 45);
            
            view.renderer = new THREE.WebGLRenderer({ antialias: true });
            view.renderer.setPixelRatio(window.devicePixelRatio);
            view.renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(view.renderer.domElement);
            
            // Lighting
            view.scene.add(new THREE.AmbientLight(0xffffff, 0.4));
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(10, 10, 20);
            view.scene.add(dirLight);
            
            // Mouse controls
            setupControls(viewKey);
        }
        
        function setupControls(viewKey) {
            const view = views[viewKey];
            const canvas = view.renderer.domElement;
            
            let isDragging = false;
            let prevMouse = { x: 0, y: 0 };
            
            canvas.addEventListener('mousedown', e => {
                isDragging = true;
                prevMouse = { x: e.clientX, y: e.clientY };
            });
            
            window.addEventListener('mouseup', () => isDragging = false);
            
            canvas.addEventListener('mousemove', e => {
                if (!isDragging) return;
                
                const dx = e.clientX - prevMouse.x;
                const dy = e.clientY - prevMouse.y;
                
                view.scene.rotation.y += dx * 0.005;
                view.scene.rotation.x += dy * 0.005;
                
                prevMouse = { x: e.clientX, y: e.clientY };
                
                // Sync rotation in overlay mode
                if (overlayMode && viewKey === 'left' && views.right.scene) {
                    views.right.scene.rotation.copy(view.scene.rotation);
                }
            });
            
            canvas.addEventListener('wheel', e => {
                e.preventDefault();
                view.camera.position.z = Math.max(10, Math.min(100, view.camera.position.z + e.deltaY * 0.05));
                
                if (overlayMode && viewKey === 'left' && views.right.camera) {
                    views.right.camera.position.z = view.camera.position.z;
                }
            }, { passive: false });
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            if (views.left.renderer) {
                views.left.renderer.render(views.left.scene, views.left.camera);
            }
            if (views.right.renderer && compareMode && !overlayMode) {
                views.right.renderer.render(views.right.scene, views.right.camera);
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // DATA EXTRACTION (Matches your JSON structure)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        /**
         * Extract circuit data from your JSON structure:
         * data[round][modelType][client][className] = { active_nodes: {...}, connectivity: {...} }
         */
        function getCircuitData(round, modelType, client, className) {
            if (!jsonData || !jsonData[round]) return null;
            
            const roundData = jsonData[round];
            if (!roundData[modelType]) return null;
            
            const modelData = roundData[modelType];
            if (!modelData[client]) return null;
            
            const clientData = modelData[client];
            if (!clientData[className]) return null;
            
            return clientData[className]; // Returns { active_nodes: {...}, connectivity: {...} }
        }
        
        /**
         * Determine layer sizes from the data
         */
        function detectLayerSizes(activeNodes, connectivity) {
            const sizes = {};
            
            LAYER_ORDER.forEach((layer, idx) => {
                let maxIdx = 0;
                
                // Check active nodes
                if (activeNodes && activeNodes[layer]) {
                    const nodes = activeNodes[layer];
                    if (nodes.length > 0) {
                        maxIdx = Math.max(maxIdx, Math.max(...nodes));
                    }
                }
                
                // Check connectivity (destination nodes are keys)
                if (connectivity && connectivity[layer]) {
                    const layerConn = connectivity[layer];
                    Object.keys(layerConn).forEach(destStr => {
                        const dest = parseInt(destStr);
                        if (!isNaN(dest)) maxIdx = Math.max(maxIdx, dest);
                    });
                }
                
                // Check previous layer sources (for this layer as destination)
                if (idx > 0 && connectivity) {
                    const prevLayer = LAYER_ORDER[idx - 1];
                    if (connectivity[layer]) {
                        Object.values(connectivity[layer]).forEach(sources => {
                            if (Array.isArray(sources)) {
                                sources.forEach(src => {
                                    if (typeof src === 'number') {
                                        // This source is in previous layer
                                    }
                                });
                            }
                        });
                    }
                }
                
                // Use known sizes as fallback, or detected + 1
                sizes[layer] = Math.max(maxIdx + 1, LAYER_SIZES[layer] || 10);
            });
            
            return sizes;
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // VISUALIZATION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function clearView(viewKey) {
            const view = views[viewKey];
            view.objects.forEach(obj => view.scene.remove(obj));
            view.objects = [];
        }
        
        function visualizeCircuit(viewKey, circuitData, title, diffData = null) {
            const view = views[viewKey];
            clearView(viewKey);
            
            if (!circuitData) return;
            
            const activeNodes = circuitData.active_nodes || {};
            const connectivity = circuitData.connectivity || {};
            
            // Store for diff calculations
            view.data = circuitData;
            
            // Detect layer sizes
            const layerSizes = detectLayerSizes(activeNodes, connectivity);
            
            // Layout parameters
            const layerSpacing = 18;
            const neuronSpacing = 0.4;
            const neuronPositions = {};
            
            let totalActiveNeurons = 0;
            let totalConnections = 0;
            
            // Diff sets (for overlay mode)
            let diffActiveNodes = null;
            let diffConnectivity = null;
            if (diffData) {
                diffActiveNodes = diffData.active_nodes || {};
                diffConnectivity = diffData.connectivity || {};
            }
            
            // â”€â”€â”€ Draw Neurons â”€â”€â”€
            LAYER_ORDER.forEach((layerName, layerIdx) => {
                const size = layerSizes[layerName];
                const activeSet = new Set(activeNodes[layerName] || []);
                
                // For diff mode
                let diffActiveSet = null;
                if (diffActiveNodes) {
                    diffActiveSet = new Set(diffActiveNodes[layerName] || []);
                }
                
                totalActiveNeurons += activeSet.size;
                
                neuronPositions[layerName] = [];
                const x = (layerIdx - (LAYER_ORDER.length - 1) / 2) * layerSpacing;
                const yOffset = (size * neuronSpacing) / 2;
                
                for (let i = 0; i < size; i++) {
                    const y = (i * neuronSpacing) - yOffset;
                    const z = 0;
                    neuronPositions[layerName][i] = new THREE.Vector3(x, y, z);
                    
                    const isActive = activeSet.has(i);
                    const isActiveInDiff = diffActiveSet ? diffActiveSet.has(i) : false;
                    
                    // Determine color based on mode
                    let color, emissive, emissiveIntensity, opacity, radius;
                    
                    if (overlayMode && diffData) {
                        if (isActive && isActiveInDiff) {
                            // Shared
                            color = 0x888888;
                            emissive = 0x444444;
                            emissiveIntensity = 0.3;
                            opacity = 0.8;
                            radius = 0.2;
                        } else if (isActive) {
                            // Only in left (current)
                            color = 0x00f5d4;
                            emissive = 0x00f5d4;
                            emissiveIntensity = 0.6;
                            opacity = 1;
                            radius = 0.25;
                        } else if (isActiveInDiff) {
                            // Only in right (diff)
                            color = 0xf72585;
                            emissive = 0xf72585;
                            emissiveIntensity = 0.6;
                            opacity = 1;
                            radius = 0.25;
                        } else {
                            // Inactive in both
                            color = 0x333340;
                            emissive = 0x000000;
                            emissiveIntensity = 0;
                            opacity = 0.15;
                            radius = 0.08;
                        }
                    } else {
                        // Normal mode
                        if (isActive) {
                            color = viewKey === 'left' ? 0x00f5d4 : 0xf72585;
                            emissive = color;
                            emissiveIntensity = 0.5;
                            opacity = 1;
                            radius = 0.22;
                        // } else {
                        //     color = 0x333340;
                        //     emissive = 0x000000;
                        //     emissiveIntensity = 0;
                        //     opacity = 0.2;
                        //     radius = 0.08;
                        // }

                        } else {
                            // Inactive in both (TURNED OFF)
                            color = 0xffffff;   // Pure White
                            emissive = 0xaaaaaa; // Slight grey glow to separate from bg
                            emissiveIntensity = 0.2;
                            opacity = 0.8;      // High opacity to be visible
                            radius = 0.12;      // Slightly larger
                        }
                    }
                    
                    const geometry = new THREE.SphereGeometry(radius, 16, 16);
                    const material = new THREE.MeshPhongMaterial({
                        color: color,
                        emissive: emissive,
                        emissiveIntensity: emissiveIntensity,
                        transparent: true,
                        opacity: opacity
                    });
                    
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.position.set(x, y, z);
                    view.scene.add(mesh);
                    view.objects.push(mesh);
                }
                
                // Layer label
                const labelCanvas = document.createElement('canvas');
                const ctx = labelCanvas.getContext('2d');
                labelCanvas.width = 256;
                labelCanvas.height = 64;
                ctx.fillStyle = 'white';
                ctx.font = 'bold 22px JetBrains Mono';
                ctx.textAlign = 'center';
                ctx.fillText(layerName.toUpperCase(), 128, 28);
                ctx.font = '14px JetBrains Mono';
                ctx.fillStyle = '#888';
                ctx.fillText(`${activeSet.size}/${size} active`, 128, 50);
                
                const texture = new THREE.CanvasTexture(labelCanvas);
                const spriteMat = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMat);
                sprite.position.set(x, yOffset + 3, 0);
                sprite.scale.set(6, 1.5, 1);
                view.scene.add(sprite);
                view.objects.push(sprite);
            });
            
            // â”€â”€â”€ Draw Connections â”€â”€â”€
            // Connectivity format: { layer: { dest_node: [src_nodes] } }
            // Connections go FROM previous layer TO current layer
            
            for (let i = 1; i < LAYER_ORDER.length; i++) {
                const dstLayer = LAYER_ORDER[i];
                const srcLayer = LAYER_ORDER[i - 1];
                
                const layerConn = connectivity[dstLayer] || {};
                const diffLayerConn = diffConnectivity ? (diffConnectivity[dstLayer] || {}) : null;
                
                // Iterate through destination nodes
                Object.entries(layerConn).forEach(([destStr, sources]) => {
                    const dest = parseInt(destStr);
                    if (isNaN(dest) || !Array.isArray(sources)) return;
                    
                    sources.forEach(src => {
                        if (typeof src !== 'number') return;
                        
                        const srcPos = neuronPositions[srcLayer]?.[src];
                        const dstPos = neuronPositions[dstLayer]?.[dest];
                        
                        if (!srcPos || !dstPos) return;
                        
                        // Determine connection color/style
                        let color, opacity, lineWidth;
                        
                        if (overlayMode && diffData) {
                            // Check if this connection exists in diff
                            const diffSources = diffLayerConn?.[destStr] || [];
                            const existsInDiff = diffSources.includes(src);
                            
                            if (existsInDiff) {
                                // Shared connection
                                color = 0xFFFF00;
                                opacity = 0.08;
                                lineWidth = 1;
                            } else {
                                // Only in current (left) - highlight
                                color = 0xf72585;
                                opacity = 0.7;
                                lineWidth = 2;
                            }
                        // } else {
                        //     // Normal mode
                        //     color = viewKey === 'left' ? 0x4361ee : 0x7209b7;
                        //     opacity = 0.12;
                        //     lineWidth = 1;
                        // }

                        } else {
                            // Normal mode
                            // Using darker blue for Left to pop against light background
                            color = viewKey === 'left' ? 0x00ffff : 0x990099; 
                            opacity = 0.35; // Increased opacity for better visibility
                            lineWidth = 1;
                        }
                        
                        const points = [srcPos, dstPos];
                        const geometry = new THREE.BufferGeometry().setFromPoints(points);
                        const material = new THREE.LineBasicMaterial({
                            color: color,
                            transparent: true,
                            opacity: opacity,
                            linewidth: lineWidth
                        });
                        
                        const line = new THREE.Line(geometry, material);
                        view.scene.add(line);
                        view.objects.push(line);
                        totalConnections++;
                    });
                });
            }
            
            // Also draw connections that only exist in diff (for overlay mode)
            if (overlayMode && diffData) {
                for (let i = 1; i < LAYER_ORDER.length; i++) {
                    const dstLayer = LAYER_ORDER[i];
                    const srcLayer = LAYER_ORDER[i - 1];
                    
                    const layerConn = connectivity[dstLayer] || {};
                    const diffLayerConn = diffConnectivity[dstLayer] || {};
                    
                    Object.entries(diffLayerConn).forEach(([destStr, diffSources]) => {
                        const dest = parseInt(destStr);
                        if (isNaN(dest) || !Array.isArray(diffSources)) return;
                        
                        const currentSources = layerConn[destStr] || [];
                        
                        diffSources.forEach(src => {
                            if (typeof src !== 'number') return;
                            
                            // Only draw if NOT in current (i.e., unique to diff/right)
                            if (currentSources.includes(src)) return;
                            
                            const srcPos = neuronPositions[srcLayer]?.[src];
                            const dstPos = neuronPositions[dstLayer]?.[dest];
                            
                            if (!srcPos || !dstPos) return;
                            
                            const points = [srcPos, dstPos];
                            const geometry = new THREE.BufferGeometry().setFromPoints(points);
                            const material = new THREE.LineBasicMaterial({
                                color: 0x00f5d4,
                                transparent: true,
                                opacity: 0.7,
                                linewidth: 2
                            });
                            
                            const line = new THREE.Line(geometry, material);
                            view.scene.add(line);
                            view.objects.push(line);
                        });
                    });
                }
            }
            
            // Update stats
            const suffix = viewKey === 'left' ? '1' : '2';
            document.getElementById('neurons' + suffix).textContent = totalActiveNeurons;
            document.getElementById('conns' + suffix).textContent = totalConnections;
            document.getElementById('label' + suffix).textContent = title;
            document.getElementById('loading').style.display = 'none';
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // UI HANDLERS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function populateDropdowns(suffix) {
            const round = document.getElementById('roundSelect').value;
            if (!jsonData || !round || !jsonData[round]) return;
            
            const modelType = document.getElementById('modelType' + suffix).value;
            const roundData = jsonData[round];
            
            // Populate clients
            const clientSelect = document.getElementById('clientSelect' + suffix);
            clientSelect.innerHTML = '<option value="">â€” Select â€”</option>';
            
            if (roundData[modelType]) {
                Object.keys(roundData[modelType]).forEach(client => {
                    const opt = document.createElement('option');
                    opt.value = client;
                    opt.textContent = client;
                    clientSelect.appendChild(opt);
                });
            }
            
            // Populate classes from first client
            const classSelect = document.getElementById('classSelect' + suffix);
            classSelect.innerHTML = '<option value="">â€” Select â€”</option>';
            
            const clients = roundData[modelType] ? Object.keys(roundData[modelType]) : [];
            if (clients.length > 0) {
                const firstClient = clients[0];
                const clientData = roundData[modelType][firstClient];
                if (clientData) {
                    Object.keys(clientData).forEach(className => {
                        const opt = document.createElement('option');
                        opt.value = className;
                        opt.textContent = className;
                        classSelect.appendChild(opt);
                    });
                }
            }
        }
        
        function updateView(viewKey) {
            const suffix = viewKey === 'left' ? '1' : '2';
            
            const round = document.getElementById('roundSelect').value;
            const modelType = document.getElementById('modelType' + suffix).value;
            const client = document.getElementById('clientSelect' + suffix).value;
            const className = document.getElementById('classSelect' + suffix).value;
            
            if (!round || !modelType || !client || !className) return;
            
            const circuitData = getCircuitData(round, modelType, client, className);
            const modelLabel = modelType.includes('local') ? 'Local' : 'Global';
            const title = `${client} | ${className} | ${modelLabel}`;
            
            // For overlay mode, get diff data
            let diffData = null;
            if (overlayMode && viewKey === 'left' && views.right.data) {
                diffData = views.right.data;
            }
            
            visualizeCircuit(viewKey, circuitData, title, diffData);
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // EVENT LISTENERS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        // File input
        document.getElementById('fileInput').addEventListener('change', e => {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = event => {
                try {
                    jsonData = JSON.parse(event.target.result);
                    
                    // Populate rounds
                    const roundSelect = document.getElementById('roundSelect');
                    roundSelect.innerHTML = '<option value="">â€” Select â€”</option>';
                    Object.keys(jsonData).forEach(round => {
                        const opt = document.createElement('option');
                        opt.value = round;
                        opt.textContent = round;
                        roundSelect.appendChild(opt);
                    });
                    
                    document.getElementById('loading').innerHTML = 
                        '<div class="icon">âœ“</div><div class="text">Select Round, Client, and Class</div>';
                    
                } catch (err) {
                    alert('Error parsing JSON: ' + err.message);
                }
            };
            reader.readAsText(file);
        });
        
        // Round select
        document.getElementById('roundSelect').addEventListener('change', () => {
            populateDropdowns('1');
            if (compareMode) populateDropdowns('2');
        });
        
        // Left panel controls
        ['modelType1', 'clientSelect1', 'classSelect1'].forEach(id => {
            document.getElementById(id).addEventListener('change', () => {
                if (id === 'modelType1') populateDropdowns('1');
                updateView('left');
            });
        });
        
        // Right panel controls
        ['modelType2', 'clientSelect2', 'classSelect2'].forEach(id => {
            document.getElementById(id).addEventListener('change', () => {
                if (id === 'modelType2') populateDropdowns('2');
                updateView('right');
            });
        });
        
        // Compare toggle
        document.getElementById('toggleCompare').addEventListener('click', function() {
            compareMode = !compareMode;
            this.classList.toggle('active');
            this.textContent = compareMode ? 'â—§ Single View' : 'â—§ Compare';
            
            const view2 = document.getElementById('view2');
            const rightControls = document.getElementById('rightControls');
            const overlayBtn = document.getElementById('toggleOverlay');
            const statNeurons2 = document.getElementById('statNeurons2');
            const statConns2 = document.getElementById('statConns2');
            
            if (compareMode) {
                view2.classList.remove('hidden');
                rightControls.style.display = 'block';
                overlayBtn.style.display = 'inline-block';
                statNeurons2.style.display = 'flex';
                statConns2.style.display = 'flex';
                
                if (!views.right.renderer) {
                    initView('right', view2);
                }
                populateDropdowns('2');
            } else {
                view2.classList.add('hidden');
                rightControls.style.display = 'none';
                overlayBtn.style.display = 'none';
                statNeurons2.style.display = 'none';
                statConns2.style.display = 'none';
                overlayMode = false;
                document.getElementById('toggleOverlay').classList.remove('active');
                document.getElementById('legend').style.display = 'none';
            }
            
            handleResize();
        });
        
        // Overlay toggle
        document.getElementById('toggleOverlay').addEventListener('click', function() {
            overlayMode = !overlayMode;
            this.classList.toggle('active');
            this.textContent = overlayMode ? 'â—‰ Side by Side' : 'â—‰ Overlay Diff';
            
            const view2 = document.getElementById('view2');
            const legend = document.getElementById('legend');
            
            if (overlayMode) {
                view2.classList.add('hidden');
                legend.style.display = 'block';
                
                // First update right view data, then update left with diff
                updateView('right');
                updateView('left');
            } else {
                view2.classList.remove('hidden');
                legend.style.display = 'none';
                updateView('left');
            }
            
            handleResize();
        });
        
        // Resize handler
        function handleResize() {
            ['left', 'right'].forEach(key => {
                const view = views[key];
                if (view.renderer && view.camera) {
                    const container = view.renderer.domElement.parentElement;
                    if (container.clientWidth > 0) {
                        view.camera.aspect = container.clientWidth / container.clientHeight;
                        view.camera.updateProjectionMatrix();
                        view.renderer.setSize(container.clientWidth, container.clientHeight);
                    }
                }
            });
        }
        window.addEventListener('resize', handleResize);
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // INIT
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        initView('left', document.getElementById('view1'));
        animate();
    </script>
</body>
</html>